#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.27p
#  in conjunction with Tcl version 8.6
#    Jan 22, 2020 05:25:22 AM CST  platform: Linux
# ======================================================
# Written by G.D. Walters
# ------------------------------------------------------
# Last modification date: 21 January, 2020
# ======================================================
import sys
from recipe_scrapers import scrape_me
from PIL import Image, ImageTk
import os
import platform
import requests
import shutil
import shared
import sqlite3
from dbutils import quote
from ScrolledCheckedListBox import ScrolledCheckedListBox
import cbv3Main
import cbv3Main_support

try:
    import Tkinter as tk
    import tkFileDialog as filedialog
    import tkMessageBox as messagebox
    import tkFont as font
    import tksimpledialog as simpledialog
except ImportError:
    import tkinter as tk
    from tkinter import messagebox
    from tkinter import font
    from tkinter import filedialog
    from tkinter import simpledialog

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True


def set_Tk_var():
    global RecipeTitle
    RecipeTitle = tk.StringVar()
    global RecipeSource
    RecipeSource = tk.StringVar()
    global RecipeServes
    RecipeServes = tk.StringVar()
    global RecipeTotalTime
    RecipeTotalTime = tk.StringVar()
    global RecipeRating
    RecipeRating = tk.StringVar()
    global che49
    che49 = tk.IntVar()
    global RecordNumber
    RecordNumber = tk.StringVar()
    RecordNumber.set('Label')
    global SelectedCats
    SelectedCats = tk.StringVar()
    SelectedCats.set('Message')


def on_btnExit():
    if shared.debug:
        print('formEditor_support.on_btnExit')
        sys.stdout.flush()
    destroy_window()


def on_btnSave():
    if shared.debug:
        print('formEditor_support.on_btnSave')
        sys.stdout.flush()


def on_chkActive():
    if shared.debug:
        print('formEditor_support.on_chkActive')
        sys.stdout.flush()


def on_customClick(s=None):
    if shared.debug:
        print('on_customClick')
    update_label()


def clear_labels():
    RecipeTotalTime.set('')
    RecipeSource.set('')
    RecipeServes.set('')
    RecipeTotalTime.set('')
    RecipeRating.set('')
    RecordNumber.set('')
    SelectedCats.set('')
    # Instructions
    w.Scrolledtext1.delete('1.0', tk.END)
    # Ingredients
    w.Scrolledlistbox1.delete(0, tk.END)
    w.Custom1.clear()


def set_labels():
    pass


def update_label():
    dat = w.Custom1.get()
    lst = []
    for x in dat:
        if len(x) == 2:
            t = x[0]
            k = x[1]
            lst.append(t)
        else:
            lst.append(x)
    s = ", ".join(lst)
    SelectedCats.set(s)


def load_image():
    original = Image.open(shared.imagePath)
    wid, hei = original.size
    if shared.debug:
        print(f'Width: {wid} - Height: {hei}')
    if wid >= hei:
        ratio = 300.0/wid
        if shared.debug:
            print(ratio)
        w2 = wid * ratio
        h2 = hei * ratio
    else:
        ratio = 300./hei
        if shared.debug:
            print(ratio)
        w2 = wid * ratio
        h2 = hei * ratio
    if shared.debug:
        print(f'New Width = {int(w2)} - New Height = {int(h2)}')
    global _img2
    _img1 = original.resize((int(w2), int(h2)), Image.ANTIALIAS)
    _img2 = ImageTk.PhotoImage(_img1)
    w.Label1.configure(image=_img2)


def fill_form():
    global connection, cursor
    clear_labels
    # Get the recipe basics
    sql = f'SELECT * FROM recipes WHERE idRecipes = {shared.rectouse}'
    print(sql)
    mainrec = list(cursor.execute(sql))
    if len(mainrec) > 0:
        print(mainrec)
        r = mainrec[0]
    RecordNumber.set(shared.rectouse)
    RecipeTitle.set(r[1])
    shared.datacheck.append(r[1])
    RecipeSource.set(r[2])
    shared.datacheck.append(r[2])
    RecipeServes.set(r[3])
    shared.datacheck.append(r[3])
    RecipeTotalTime.set(r[4])
    shared.datacheck.append(r[4])
    RecipeRating.set(r[5])
    shared.datacheck.append(r[5])
    if r[6] == 1:
        che49.set(1)
        shared.IsActive = True
    else:
        che49.set(0)
        shared.IsActive = False
    shared.datacheck.append(shared.IsActive)
    w.stNotes.insert(tk.END, r[8])
    shared.datacheck.append(r[8])
    # Now fill in the image, if there is one.
    shared.imagePath = ''
    sql = (f'SELECT * FROM images WHERE recipeID = {shared.rectouse}')
    imgrec = list(cursor.execute(sql))
    if len(imgrec) > 0:
        r = imgrec[0]
        shared.imagePath = r[2]
    shared.datacheck.append(shared.imagePath)
    if shared.imagePath != '':
        load_image()
    # ===================================
    # Fill in the ingredients
    # ===================================
    sql = (
        f'SELECT IngredientItem from ingredients WHERE RecipeID = {shared.rectouse}')
    ingRecs = list(cursor.execute(sql))
    if len(ingRecs) > 0:
        for i in ingRecs:
            w.Scrolledlistbox1.insert('end', str(i[0]))
    shared.datacheck.append(ingRecs)
    # ===================================
    # Fill in the instructions
    # ===================================
    sql = (
        f"SELECT InstructionsData FROM instructions WHERE RecipeID = {shared.rectouse}")
    recs = list(cursor.execute(sql))
    for r in recs:
        w.Scrolledtext1.insert(tk.END, r[0])
    shared.datacheck.append(recs)
    # ===================================
    # Set the categories
    # ===================================
    sql2 = ("SELECT recipes.idRecipes,"
            "categoriesmain.CatText "
            "FROM recipes "
            "INNER JOIN recipecategories ON "
            "(recipes.idRecipes=recipecategories.RecipeId) "
            "INNER JOIN categoriesmain ON "
            "(recipecategories.MainCatKey=categoriesmain.idCategoriesMain) "
            "WHERE recipes.idRecipes = {0}").format(shared.rectouse)
    cats = list(cursor.execute(sql2))
    if len(cats):
        # print(cats)
        tlist = []
        for r in cats:
            tlist.append(r[1])
            # w.Custom1.set(r[1])
            # tlist.append(r[1])
            # tlist.append(r[0])
            # catlist.append(tlist)
            # tlist = []
    w.Custom1.set(tlist)
    update_label()
    x = w.Custom1.get()
    # print(x)
    shared.datacheck.append(x)
    # ===================================
    shared.isDirty = False

    print('Datacheck:')
    # print(shared.datacheck)


def start_up():
    global connection, cursor

    connection = sqlite3.Connection("./database/cookbook-original.db")
    cursor = connection.cursor()
    # set up for cursors
    global busyCursor, preBusyCursors, busyWidgets
    busyCursor = 'watch'
    preBusyCursors = None
    busyWidgets = (root, )
    # Clear the text from the image label
    lblImage = w.Label1
    lblImage.configure(text='')
    # Set up the debug flag
    shared.debug = True
    shared.datacheck = []
    # Fill the entry widget for testing purposes
    initialize_custom_widget()
    # set the window icon
    set_icon()
    # Centre the screen
    centre_screen(1139, 773)


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    # ======================================================
    # My init code starts...
    # ======================================================
    global version
    version = '0.1.0'
    pv = platform.python_version()
    print(f"Running under Python {pv}")
    # Set the path for the icon files
    global path1
    path1 = os.getcwd()
    print(path1)
    print(f"Version: {version}")
    progname = 'Editor v' + version
    root.title(progname)
    start_up()
    # Record to use for testing/development
    shared.rectouse = 118  # 108
    fill_form()


def get_Custom_Cats():
    global connection, cursor
    sql = 'SELECT CatText, idCategoriesMain FROM categoriesmain order by CatText ASC'
    recs = list(cursor.execute(sql))
    if shared.debug:
        print(recs)
    return recs
    # if len(recs) > 0:
    #     for r in recs:


def initialize_custom_widget():
    w.Custom1.cback = on_customClick
    # To use a single list of item names comment out the next line and
    # uncomment the second line down.
    ListInfo2 = get_Custom_Cats()
    w.Custom1.load(ListInfo2)
    w.Custom1.clear()
    # w.Custom1.load(ListInfo)
    # clear_label()
    # set_labels()

# =================================================================
# cursor stuff
# =================================================================


def busyStart(newcursor=None):
    global preBusyCursors

    if not newcursor:
        newcursor = busyCursor
    newPreBusyCursors = {}
    for component in busyWidgets:
        newPreBusyCursors[component] = component['cursor']
        component.configure(cursor=newcursor)
        component.update_idletasks()
    preBusyCursors = (newPreBusyCursors, preBusyCursors)


def busyEnd():
    global preBusyCursors
    if not preBusyCursors:
        return
    oldPreBusyCursors = preBusyCursors[0]
    preBusyCursors = preBusyCursors[1]
    for component in busyWidgets:
        try:
            component.configure(cursor=oldPreBusyCursors[component])
        except KeyError:
            pass
        component.update_idletasks()


def centre_screen(wid, hei):
    ws = root.winfo_screenwidth()
    hs = root.winfo_screenheight()
    x = (ws/2) - (wid/2)
    y = (hs/2) - (hei/2)
    root.geometry('%dx%d+%d+%d' % (wid, hei, x, y))

# =================================================================
# Window stuff
# =================================================================


def show_me():
    root.deiconify()
    root.attributes("-topmost", True)


def hide_me():
    cbv3Main_support.show_me()
    root.withdraw()


def set_icon():
    # ======================================================
    # Sets the application icon...
    # ======================================================
    # global p1
    # p1 = tk.Image("photo", file='images/chef.png')
    shared.p1 = ImageTk.PhotoImage(file='images/chef.png')
    root.tk.call('wm', 'iconphoto', root._w, shared.p1)


# Custom = tk.Frame  # To be updated by user with name of custom widget.
Custom = ScrolledCheckedListBox


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


if __name__ == '__main__':
    import formEditor
    formEditor.vp_start_gui()
